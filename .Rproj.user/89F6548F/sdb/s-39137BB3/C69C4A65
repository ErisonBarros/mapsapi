{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Introduction to package `mapsapi`\"\nauthor: \"Michael Dorman\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Vignette Title}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n## Introduction\n\nThe `mapsapi` package provides an interface to the Google Maps APIs, currently two of them - \n\n* <a href=\"https://developers.google.com/maps/documentation/directions/\" target=\"_blank\">Google Maps Direction API</a>\n* <a href=\"https://developers.google.com/maps/documentation/distance-matrix/\" target=\"_blank\">Google Maps Distance Matrix API</a>\n\nFunctions `google_directions` and `google_matrix` are used to access the API. They return an `xml_2_document` object (package `xml2`) with the response contents.  \n\nGiven a *directions* response, functions `extract_routes` and `extract_segments` can be used to process the response document into a spatial layer. Function `extract_routes` gives each alternative as a separate line, while function `extract_segments` gives each segment (that is, a portion of the route associated with specific driving instructions) as a separate line.  \n\n## Installation\n\nThe package can be installed from GitHub -\n\n```{r, eval=FALSE}\ninstall.packages(\"devtools\")\ndevtools::install_github(\"michaeldorman/mapsapi\")\n```\n\nAnd loaded with `library` - \n\n```{r}\nlibrary(mapsapi)\n```\n\n## Directions\n\nThe following expression queries the Directions API for driving directions from Tel-Aviv and Haifa. Note that locations can be specified as a coordinate pair, a textual address or an `sf` spatial object. \n\n```{r}\ndoc = google_directions(\n  origin = c(34.81127, 31.89277),\n  destination = \"Haifa\",\n  alternatives = TRUE\n)\n```\n\nGiven the response object, we can use `extract_routes` to create a spatial layer of route lines - \n\n```{r}\nr = extract_routes(doc)\n```\n\nHere is the resulting object - \n\n```{r}\nr\n```\n\nAnd a visualization using `leaflet` - \n\n```{r}\nlibrary(leaflet)\npal = colorFactor(palette = \"Dark2\", domain = r$alternative_id)\nleaflet() %>% \n  addProviderTiles(provider = providers$Stamen.TonerLite) %>% \n  addPolylines(data = r, opacity = 1, weight = 7, color = ~pal(alternative_id))\n```\n\nSeparate segments can be extracted from the same response using `extract_segments` - \n\n```{r}\nseg = extract_segments(doc)\n```\n\nHere are the first six features of the resulting object - \n\n```{r}\nhead(seg)\n```\n\nAnd a visualization - \n\n```{r}\npal = colorFactor(palette = sample(colors(), length(unique(seg$segment_id))), domain = seg$segment_id)\nleaflet(seg) %>% \n  addProviderTiles(provider = providers$Stamen.TonerLite) %>% \n  addPolylines(opacity = 1, weight = 7, color = ~pal(segment_id), popup = ~instructions)\n```\n\n## Distance Matrix\n\nThe following expression queries the Distance Matrix API to obtain a matrix of driving distance and duration between all combinations of three locations: Tel-Aviv, Jerusalem and Beer-Sheva. \n\n```{r}\nlocations = c(\"Tel-Aviv\", \"Jerusalem\", \"Beer-Sheva\")\ndoc = google_matrix(\n  origins = locations,\n  destinations = locations\n)\n```\n\nThe `extract_matrix` function can then be used to process the XML reposne into a `matrix`. Possible values of the matrix include -\n\n* `distance_m` - Distance, in meters\n* `distance_text` - Distance, textual description\n* `duration_s` - Duration, in seconds\n* `duration_text` - Duration, textual description\n\n```{r}\nm = extract_matrix(doc, value = \"distance_m\")\ncolnames(m) = locations\nrownames(m) = locations\nm\n```\n\n\n\n\n",
    "created" : 1506317156447.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2057762085",
    "id" : "C69C4A65",
    "lastKnownWriteTime" : 1506317265,
    "last_content_update" : 1506317752610,
    "path" : "~/Dropbox/Packages/mapsapi/vignettes/intro.Rmd",
    "project_path" : "vignettes/intro.Rmd",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}